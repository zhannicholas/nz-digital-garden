---
date: "2020-12-13T19:36:01+08:00"
title: "操作系统：进程与线程"
authors: Nicholas Zhan
categories:
  - OS
tags:
  - OS
draft: false
toc: true
---

操作系统中最核心的概念是进程：它是对正在运行的程序的一个抽象。进程通常需要做很多事情，比如游戏运行起来就是一个进程，游戏内部需要渲染图形、响应用户操作、连接网络等，为了保障良好的用户体验，这些功能不能相互阻塞，因此需要多线程；进程需要空间存储指令和数据，因此用到了内存；有时候，进程需要将一部分数据持久化保存，这就用到了文件系统……

## 进程

**进程（process）** 是对正在运行的程序的一个抽象，代表一个正在执行的程序的实例，包括程序计数器、寄存器和变量的当前值。也可以这么说，进程是程序启动后在内存中创建的一个执行副本。

### 进程的创建

通常有 4 种事件会导致进程的创建：
1. 系统初始化。
2. 正在运行的程序执行了创建进程的系统调用。
3. 用户请求创建一个新进程。
4. 一个批处理作业的初始化。

从技术上看，在所有这些情形中，新进程都是由于一个已经存在的进程执行了一个用于创建进程的系统调用而出现的。

在 UNIX 系统中，创建新进程使用的是系统调用 `fork`，而 Windows 中则是`CreateProcess` 函数。在 UNIX 和 Windows 中，进程创建之后，父进程和子进程有各自不同的地址空间。如果其中某个进程修改了其地址空间内的一个字，其它进程是察觉不到的。在 UNIX 中，子进程的初始地址空间是父进程地址空间的一个副本，但这里其实有涉及到两个不同的地址空间。**不可写的内存是共享的**。一些 UNIX 系统在父子进程之间共享程序正文，因为程序正文是不可修改的。子进程也可能会共享父进程所有的内存，但这种情况下采用的是 `copy-on-write` 这种共享方式，一旦有进程想要修改部分内存，就必须先复制这块地址空间，以确保修改发生在私有区域。**可写的内存是不可共享的**。在 Windows 中，父进程的地址空间和子进程的地址空间从一开始就是不同的。

### 进程的终止

进程在创建之后，就开始运行，完成其工作。进程会在某些条件下终止：

1. 正常退出（自愿的）。多数进程是由于完成了它们工作而终止，这个时候它们会执行一个系统调用而退出。在 UNIX 中该调用是 `exit`，Windows 中则是`ExitProcess`。
2. 出错退出（自愿的）。例如需要的文件不存在。
3. 严重错误（非自愿）。例如执行了非法指令、引用了不可访问的内存等。
4. 被其它进程杀死（非自愿）。某个进程执行一个系统调用通知草走系统杀死某个其它进程。在 UNIX 中，这个调用是 `kill`，Windows 中，则是 `TerminateProcess` 函数。

### 进程的状态

每个进程都是一个独立的实体，有自己的程序计数器和内部状态。进程之间经常相互作用，从而导致进程状态的迁移。

![进程状态迁移](/images/operating_systems/processes_management/process-state-translations.png)

### 进程的实现

为了实现进程，操作系统维护着一张 **进程表（process table）**，又称 **进程控制块（process control block）**。每个进程占用一个进程表项。进程表项包含了进程状态的重要信息，包括程序计数器、堆栈指针、内存分配情况、所打开文件的状态、账号和调度信息，以及其它在进程由运行态转为就绪或阻塞态时必须保存的信息，从而保证该进程随后能再次启动，就像从未被中断过一样。一个进程在执行过程中可能被中断数千次，但每当被中断的进程被重新被执行时，操作系统都会将进程状态恢复到中断发生前进程的状态。



## 线程

**线程（thread）** 具有很多进程的特质，又被称为 **轻量级进程（lightweight process）**。进程把资源集中在一起（资源管理的单位是进程），而线程则是在 CPU 上被调度执行的实体。一个进程内的多个线程共享同一个地址空间和其它资源。每个进程都有自己独立的地址空间，而一个进程内的多个线程都有完全一样的地址空间，这意味着它们也共享同样的全局变量。由于各个线程都可以访问进程地址空间中的每一个内存地址，所以一个线程可以读、写、甚至清除另一个线程的堆栈，线程之间是没有保护的。

每个进程的中内容有：地址空间、全局变量、打开的文件、子进程、时钟信息、信号与信号处理程序、账户信息。而每个线程中的内容有：程序计数器、寄存器、堆栈、状态。每个线程都有自己的堆栈，堆栈中的栈帧供各个被调用但是还没有从中返回的过程使用，栈帧保存了相应过程的局部变量以及过程调用完之后使用的返回地址。

## 进程间通信

有时候，进程之间需要相互通信。进程间通信需要解决的三个问题：
1. 进程如何把信息传递给其它进程。
2. 如何确保两个或更多的进程在关键活动中不会出现交叉。
3. 当进程间出现依赖时，如何保证正确的顺序。

### 临界区

 **竞争条件（race condition）** 说的是两个或多个进程对共享资源的读写存在竞争，当所有的进程执行完成后，共享资源的值是不可预测的，因为它取决于进程执行的精确顺序。

避免竞争条件的关键在于阻止多个进程同时读写共享资源。换言之，我们需要的是 **互斥（mutual exclusion）**，即确保一个进程在使用某个共享资源时，其它的进程不能做同样的操作。程序中访问共享资源的那一部分代码称为 **临界区域（critical region）** 或 **临界区（critical section）**，临界区内共享资源的访问操作必须被同步，否则数据的一致性就得不到保证。

如果我们精心地安排进程的执行顺序，防止多个进程同时读写临界区，就能避免竞争条件。一个好的解决方案需要满足以下 4 个条件：

1. 不会出现两个进程同时在临界区内的情况。
2. 不对 CPU 的速度和数量做任何假设。
3. 运行在临界区外的进程不应该阻塞任何进程。
4. 进程在进入临界区前不会无限等待。

以两个进程为例，我们期望它们的行为是这样的：

![使用临界区的互斥](/images/operating_systems/processes_management/mutex-exclusion-using-critical-regions.png)

### 基于忙等待的互斥
接下来会介绍几种基于忙等待实现的互斥方案。在这些方案中，在一个进程在临界区中更新共享内存期间，其它进程不会进入临界区，也不会带来麻烦。

#### 屏蔽中断

在单处理器系统中，最简单的方法是使每个进程在进入临界区后就立即屏蔽所有中断，并在将要离开临界区之前再次打开中断。因为CPU只有在发生时钟中断或其它中断时才会进行进程切换，屏蔽中断后CPU就不会再进行进程切换了。于是，一旦某个进程屏蔽中断后，它就可以检查和修改共享内存，而不必担心其它进程介入。

这并不是一个好方案，如果某个进程屏蔽中断后不再打开中断，那么整个系统可能因此而终止。对于多处理器系统，屏蔽中断仅仅对于执行 `disable `指令的那个 CPU 有效，其它 CPU 仍继续运行，并可以访问共享内存。

另一方面，对内核来说，当它在更新变量或列表的几条指令期间将中断屏蔽是很方便的。屏蔽中断对操作系统本身而言是一项很有用的技术，但对于用户进程则不是一种合适的通用互斥机制。

#### 锁变量

假设有一个共享（锁）变量，其初始值为0。当一个进程想进入其临界区时，它首先查看这把锁，如果锁的值为0，就将其设置为1并进入临界区。若锁的值为1，则一直等待直到锁的值变为0。于是，0表示临界区内无进程，而1表示临界区内有进程。

但是，这种想法也会出现竞争条件。假设一个进程读出锁变量的值并发现它为0，而恰好在它将锁的值设置为1之前，另一个进程被调度运行，将锁变量的值设置为1。当第一个进程再次运行时，它同样也将锁的值设置为1，则此时有两个进程同时在临界区内。另一方面，我们获取可以在改变锁变量的值之前再次检查锁变量的值，但如果第二个进程恰好在第一个进程检查完之后修改了锁变量的值，同样会出现竞争条件。

#### 严格轮转法

以下展示了一种用于两个进程互斥的算法。
进程0：
```C
while （TRUE） {
    while （turn != 0）;  // 循环等待
    critical_region（）;
    turn = 1;
    noncritical_region（）;
}
```
进程1：
```C
while （TRUE） {
    while （turn != 1）;  // 循环等待
    critical_region（）;
    turn = 0;
    noncritical_region（）;
}
```
线程0和线程1通过检查共享变量`turn`的取值来决定是否进入临界区。变量`turn`的初始值为`0`，表示进程0可以进入临界区。开始时，进程0检查`turn`，发现为0，于是进入临界区。进程1也发现`turn`为0，所以在一个循环中不停的测试`turn`，直到其值变为`1`。连续测试一个变量直到某个值出现为止，称为**忙等待（busy waiting）**。由于这种方式会浪费CPU的时间，所以通常应该避免。只有在有理由认为等待时间非常短的情形下，才使用忙等待。用于忙等待的锁，称为**自旋锁（spin lock）**。

进程0离开临界区时，将`turn`设置为1，以便允许进程1进入临界区。假设进程1很快便离开了临界区，它将`turn`设置为0，这个时候两个进程都处于临界区外。现在进程0再次进入外层循环，它进入临界区又退出，`turn`的值变为1。此时，两个线程都在临界区外执行。突然，进程0再次完成非临界区的操作而回到循环的开始位置，但这个时候它并不能进入临界区，因为`turn`当前的值为1，因为此时进程1还在忙于非临界区的操作，进程0只有自旋等待，直到进程1把`turn`变为0为止。这说明：<u>在一个进程比另一个进程慢了很多的情况下，轮流进入临界区并不是一个好办法</u>。

该方案要求两个进程严格地轮流进入临界区，避免了所有的竞争条件。由于方案中出现了<u>临界区外的进程阻塞其它进程</u>的情况，违反了条件3，所以不能作为一个很好的备选方案。

#### Peterson算法

Peterson于1981年提出了一种新的互斥算法，克服了严格轮转法的缺点：
```C
#define FALSE 0
#define TRUE 1
#define N 2     // 进程数量

int turn;       // 谁可以进入临界区
int interested[N];

void enter_region（int process） {    // 进程是0或1
    int other = 1 - process;        // 另一个进程号
    interested[process] = TRUE;     // 表示准备进入临界区
    turn = process;                 // 表示谁正在等待进入临界区
    while （turn == process && interested[other] == TRUE）;   // 循环等待
}

void leave_region（int process） {
    interested[process] = FALSE;    // 表示离开临界区
}
```
在进入其临界区之前，各个进程使用自己进程号0或1作为`enter_region`的参数。该调用在需要时将使进程等待，直到能安全地进入临界区。在完成对共享变量的操作之后，进程将调用`leave_region`离开临界区。若其它进程希望进入临界区，现在就能进入。

一开始，没有任何进程处于临界区中，现在进程0调用`enter_region`，它通过设置其数组元素和将`turn`置为0来标识它希望进入临界区。由于进程1并在临界区内，所以`enter_region`很快返回，如果进程1现在调用`enter_region`，进程1将在此处循环等待直到`interested[0]`变成`FASLE`，而这只有在进程0调用`leave_region`退出临界区时才会发生。

现在考虑两个进程几乎同时调用`enter_region`的情况，它们将自己的进程号存入`turn`，但时只有后设置的进程号才会生效，前一个因为被重写而丢失。假设进程1是后存入的，则`turn`为1。当两个进程都运行到`while`语句时，进程0将循环0次并进入临界区，而进程1由于`while`条件不满足而不能进入临界区，它需要一直循环直到进程0退出临界区为止。`turn`变量可以理解为：现在轮到谁，即谁正在等待进入临界区。

#### 基于硬件的解决方案

在某些计算机中，特别是那些设计为多处理器的计算机，都有下面一条指令：
```asm
TSL RX,  LOCK
```
称为测试并加锁（test and set lock）。它将一个内存字`lock`读取到寄存器`RX`中，然后在该内存地址上存一个非零值。读字和写字操作保证是不可分割的，即该指令结束之前其他处理器均不允许访问该内存字。<u>执行`TSL`指令的CPU将 **锁住内存总线**，以禁止其它CPU在该指令结束之前访问内存</u>。

为了使用`TSL`指令，需要使用一个共享变量`lock`来协调对共享内存的访问。当`lock`为0时，任何进程都可以使用`TSL`指令将其设置为1并读写共享内存。当操作结束时，进程调用一条普通的`MOVE`指令将`lock`的值重新设置为0。
```asm
enter_region:
    TSL REGISTER,LOCK       | 将LOCK中的值复制到REGISTER并将LOCK的值置为1
    CMP REGISTER,#0         | REGISTER中的值为0吗？
    JNE enter_region        | 若非零，说明锁不可用，循环
    RET                     | 返回；进入临界区

leave_region:
    MOVE LOCK,#0            | 将LOCK的值置为0
    RET                     | 返回
```
`enter_region`的第一条指令将`lock`的旧值复制到寄存器并将`lock`的新值设置为1，随后将`lock`的旧值与0相比较，若非0，则说明锁已被使用，则程序回到开始并再次测试。重复这个过程直到`lock`的值为0，于是过程返回，加锁成功。要清除锁非常简单，程序只需要将0存入`lock`即可。

一个可以替代`TSL`的指令是`XCHG`，它原子的交换两个位置的内容。以下解法和`TSL`解法本质上是一样的：
```asm
enter_region:
    MOVE REGISTER,#1        | 将1存入REGISTER
    XCHG REGISTER,LOCK      | 交换REGISTER与LOCK的值
    CMP REGISTER,#0         | REGISTER中的值为0吗？
    JNE enter_region        | 若非零，说明锁不可用，循环
    RET                     | 返回；进入临界区

leave_region:
    MOVE LOCK,#0            | 将LOCK的值置为0
    RET                     | 返回
```

进程在进入临界区之前先调用`enter_region`，这将导致忙等待，直到锁空闲为止，随后进程获得锁并返回。进程从临界区返回时调用`leave_region`，将`lock`设置为0。与其它基于临界区问题的解法一样，进程必须在正确的时间调用`enter_region`和`leave_region`，解法才能奏效。也就是说：临界区能否工作取决于进程是否遵守协定。

### 睡眠与唤醒

Peterson算法和基于`TSL`或`XCHG`的解决方案都是正确的，但它们都有忙等待的缺点。这些解法的本质是：<u>当一个进程想要进入临界区时，先检查是否允许进入，若不允许，则原地自旋等待，直到允许为止</u>。这种方法不仅浪费CPU时间，而且还可能引发预想不到的问题，例如优先级反转问题。

现在来考察另一组进程间通信原语，它们在无法进入临界区时将阻塞，而不是忙等待。最简单的就是`sleep`和`wakeup`。`sleep`是一个将引起调用进程阻塞的系统调用，即进程被挂起，直到另一个进程将其唤醒。`wakeup`只有一个参数，即要被唤醒的进程。

#### 生产者消费者问题

生产者消费者问题也称叫有限缓冲区问题。两个进程共享一个公共的固定大小的缓冲区，其中一个是生产者，它将消息放入缓冲区；另一个是消费者，它从缓冲区内取出消息。当缓冲区已满，生产者将被阻塞，直到消费者从缓存区中取走数据并将其唤醒。同样的，当消费者试图从缓冲区中取消息而发现缓冲区为空时，消费者就睡眠，直到生产者向缓冲区中放入消息并将其唤醒。

我们需要一个变量`count`来追踪缓冲区中消息的数量。如果缓冲区的容量为`N`，则生产者将首先检查`count`是否达到了`N`，若是，则生产者睡眠；否则生产者向缓冲区中放入一条消息并将`count`值加1。消费者首先测试`count`是否为0，若是，则睡眠；否则取走一条消息并将`count`减1。每个进程同时也会检测是否需要唤醒另一个进程。
```C
# define N 100;     // 缓冲区容量
int count = 0;      // 缓冲区中消息的数量

void producer（void） {
    while （TRUE） {
        int item = product_item（）;  // 生产一条消息
        if （count == N） sleep（）;    // 缓冲区满了，睡眠
        put（item）;                  // 放入一条消息到缓冲区
        count++;                    // 缓冲区中消息数量加1
        if （count == 1） wakeup（consumer）;   // 若放入消息之前缓冲区是空的，则唤醒消费者
    }
}

void consumer（void） {
    while （TRUE） {
        if （count == 0） sleep（）;    // 缓冲区是空的，睡眠
        int item = take（）;          // 取走一条消息
        count--;                    // 缓冲区中消息数量减1
        if （count == N - 1） wakeup（producer）;   // 如果取走消息前缓冲区是满的，则唤醒生产者
        consume（item）;              // 消费
    }
}
```
这里可能出现竞争条件，原因是对`count`的访问未加限制。有可能出现以下情况：缓冲区为空，消费者读取到的`count`值为0。此时调度程序决定挂起消费者并启动生产者，生产者放入一个数据项到缓冲区，`count`变为1。生产者推断认为由于刚才`count`为0，所以消费者一定在睡眠，所以调用`wakeup`唤醒消费者。但是，消费者此时并没有睡眠，所以`wakeup`信号丢失。当消费者下次运行时，它继续测试之前读到的`count`值，依旧为挂起之前的值0，于是睡眠。这样下去，生产者迟早会填满整个缓冲区，然后睡眠，最终两个进程都将永远睡眠下去。

问题的实质在于发给一个未睡眠进程的`wakeup`信号丢失了。一种快速的弥补方法就是修改规则，加上一个**唤醒等待位**。当一个`wakeup`信号发给一个清醒的进程时，将该位置1，随后当进程尝试睡眠时，若唤醒等待位为1，则将其清零，就不睡眠而是保持清醒。

#### 信号量

**信号量（semaphore）** 是Dijkstra在1965年提出的一种方法，它使用一个整型变量记录唤醒次数，供以后使用。一个信号量的取值可以是0（表示当前没有睡眠的进程）或者为正值（表示当前有一个或多个进程处于睡眠状态，等待被唤醒）。以下的检查信号量的值、修改信号量的值和睡眠操作均需要保证是原子操作。

信号量支持两种操作：`down`和`up`（分别对应于广义的`sleep`和`wakeup`）。对一个信号量执行`down`操作时，会先检查其值是否大于0，若大于0，则将其减一（用掉一个唤醒信号，即睡眠进程的数量减一）并继续；若信号量的值为0，则进程将睡眠，而且此时`down`操作未结束。`up`操作对信号量的值加1，如果有一个或者多个进程在该信号量上睡眠（即先前的`down`操作还未完成），系统会选取一个进程并允许它完成之前的`down1=`操作。于是，对一个有进程在其上睡眠的信号量来说，执行一次`up`操作之后，信号量的值依旧为0，只是在其上睡眠的进程少了一个。

##### 用信号量解决生产者-消费者问题
为确保信号量能正确工作，需要采用一种原子的方式来实现它。通常将`up`和`down`作为系统调用来实现，而且操作系统只需要在执行以下操作时暂时屏蔽中断：测试信号量、更新信号量以及在需要时使某个进程睡眠。

生产者-消费者问题的解决方案使用了三个信号量：`full`记录满缓冲槽数量，`empty`记录空缓冲槽数量，`mutex`控制对临界区的访问，确保生产者和消费者不会同时进入缓冲区。`mutex`的初值为1，保证同时只有一个进程可以进入临界区，称作**二元信号量（binary semaphore）**。
```C
#define N 100
typedef int semaphore
semaphore full = 0;         // 慢缓冲槽数量
semaphore empty = N;        // 空缓冲槽数量
semaphore mutex = 1;        // 控制对临界区的访问

void producer（void） {
    while （TRUE） {
        int item = produce_item（）;  // 生产一条消息
        down（&empty）;               // 空槽数量减1
        down（&mutex）;               // 进入临界区
        put（item）;                  // 将消息放到缓冲区
        up（&mutex）;                 // 离开临界区
        up（&full）;                  // 满槽数量加1
    }
}

void consumer（void） {
    while （TRUE） {
        down（&full）;                // 满槽数量减1
        down（&mutex）;               // 进入临界区
        int item = take（）;          // 从缓冲区取走一条数据
        up（&mutex）;                 // 离开临界区
        up（&empty）;                 // 空槽数量加1
        consume（item）;              // 消费
    }
}
```
以上展示了信号量的两种用法：`mutex`用于互斥，保证任一时刻只有一个进程读写缓冲区中的变量，而`empty`和`full`用于同步，保证某些事件的顺序发生或不发生。

#### 互斥量

如果不需要信号量的计数能力，有时候可以使用信号量的一个简化版本，称为**互斥量（mutex）**。互斥量仅适用于管理一些共享资源或一小段代码。它是一个只有可能处于两种状态中的一种的变量：解锁和加锁。

当一个进程需要访问临界区时，它调用`mutex_lock`。若`mutex`为0，表示临界区内无进程，则进入临界区；若`mutex`为1，表示当前临界区内有进程，调用线程将被阻塞，直到临界区中的进程完成并调用`mutex_unlock`释放锁。如果多个进程在该互斥量上阻塞，将随机选择一个进程并允许它获得锁。
```asm
mutex_lock:
    TSL REGISTER,MUTEX          | 先将mutex的值复制到GEGISTER，然后将mutex置为1
    CMP REGISTER,#0             | 检查REGISTER中的值是否为0
    JZE ok                      | 若为0，表示未上锁，成功获得锁，返回
    CALL thread_yield           | 若非0，调度另一个线程运行
    JMP mutex_lock              | 稍后重试
ok: RET                         | 返回，进入临界区

mutex_unlock:
    MOVE REGISTER,#0            | 将mutex置为0
    RET                         | 释放锁，返回
```
这段代码与之前采用基于`TSL`的硬件解决方案中的`enter_region`的代码很相似，但有一个关键区别：当`enter_region`进入临界区失败时，它始终自旋等待；而`mutex_lock`在获取锁失败时，它调用`thread_yield`让出CPU的使用权，这样就没有忙等待。当该进程再次获得CPU时，它将再次尝试获取锁。

#### 管程

**管程（monitor）** 是一种高级同步原语。一个管程是一个由过程、变量、数据结构等组成的一个集合，他们组成一个特殊的模块或软件包。进程可以在任何需要的时候调用管程中的过程，但他们不能在管程之外声明的过程中直接访问管程内的数据结构。

管程有一个很重要的特性，即任一时刻管程中只能有一个活跃进程，这一特性使管程能够有效地完成互斥。管程是编程语言的组成部分，进入管程时的互斥由编译器完成，C语言并不支持管程，而Java支持管程。

### 消息传递

**消息传递（message passing）** 是一种进程间通信的方法，它使用了两条原语：`send`和`receive`。`send`给接收方发送一条消息，而`receive`从发送方接收一条消息。如果没有消息可用，接收方可能会阻塞直到消息到达，也可能带一个错误码立即返回。

为了防止消息丢失，发送方和接收方可以达成以下协议：一旦收到消息，接收方马上会送一条确认消息。如果发送方在一定时间内未收到确认，则重传该消息。

### 屏障

在有些应用中划分了若干阶段，并且规定，除非所有的进程都准备好进入下一阶段，否则任何进程都不能进入下一阶段。可以通过在每个阶段的结尾放置 **屏障（barrier）** 来实现这种行为。当一个进程到达屏障，它会被屏障阻拦，直到所有进程都到达该屏障才一并放行。屏障可用于一组线程的同步。

### 避免锁：读-复制-更新

最快的锁就是根本没有锁。在某些情况下，我们可以允许写操作更新数据结构，即便还有进程正在使用它。关键在于确保每个读操作要么读取数据的旧版本，要么读取数据的新版本，绝不能是新旧版本数据的组合。

## 进程调度

当两个进程同时竞争一个 CPU 时，必须选择出一个进程让其获得 CPU。在操作系统中，完成选择工作的组件被称为 **调度程序（scheduler）**，调度程序可能根据实际情况采用不同的调度算法。

有些进程会将绝大多数时间花在计算上，而有些进程会被大多数时间花在 I/O 上。前者称为**计算密集型（computed-bound）**，后者称为**I/O 密集型（I/O-bound）**：

![Computed-bound vs I/O-bound](/images/operating_systems/processes_management/computed-bound-vs-io-bound.png)

调度的一个关键问题就是合适进行调度，有多种情形需要调度。例如：
* 在创建一个新进程之后，是运行父进程还是子进程。
* 当一个进程退出时，必须从就绪进程中选取一个运行。如果没有就绪进程，通常会运行一个系统提供的空闲进程。
* 当一个进程由于 I/O 或其它原因阻塞时，需要选择另一个进程运行。
* 当一个 I/O 中断发生时，必须做出调度决策。

### 调度算法

根据时钟中断时做出的调度决策，可以将调度算法分为两类：**非抢占式**调度算法挑选一个进程，然后让该进程运行至阻塞，或者直到该进程自动释放CPU，该进程不会被强迫挂起。**抢占式**调度算法挑选一个进程，让该进程运行一段时间，如果时间到了且该进程仍在运行，则将它挂起并运行其它就绪进程。抢占式调度算法依赖时钟中断，以便调度程序能够获得CPU的控制权。

#### 调度算法的目标

对于不同的操作系统环境，采取的调度算法也是不同的，常见的环境有：**批处理系统**、**交互式系统**、**实时系统**。为了设计调度算法，我们有必要考虑什么是一个好的调度算法。某些目标取决于操作环境，而某些目标又是通用的。

在所有的情形中，公平是很重要的。相似的进程应该得到相近的对待，给其中一个进程更多的 CPU 份额是不公平的。操作系统可能需要强制施行某些策略以保证公平性。另一个共同目标是保持系统的所有部分尽可能地忙碌，完成尽可能多的工作。

对于批处理系统，通常使用以下 3 个指标来衡量系统的工作状态：
* 吞吐量。吞吐量指系统每小时完成的作业数量。
* 周转时间。周转时间指从一个批处理作业提交到完成的平均时间。
* CPU 利用率。CPU 利用率用来衡量 CPU 的繁忙程度。

对于交互式系统，最重要的就是最小响应时间，即从发出命令到得到响应之间的时间。

实时系统有着与交互式系统不同的特性，所以有着不同的调度目标。一般来说，实时系统或多或少都必须满足截止时间。作为一种以时间为主导的系统，实时系统可以分为 **硬实时（hard real time）** 和 **软实时（soft real time）**。前者表示任务必须满足绝对的截止时间，而后者能够容忍任务偶尔超过截止时间。

#### 常见的调度算法

批处理系统中常用的调度算法有：先来先服务（first-come first-served）、最短作业优先（shortest job first）和最短剩余时间优先（shortest remaining time next）。

**轮转调度（round robin）**：每个进程被分配一个时间段，称为**时间片（quantum）**，即允许该进程在该时间片内运行。如果在时间片结束时进程还在运行，将剥夺CPU并分配给另外一个进程。如果该进程在时间片结束前阻塞或结束，CPU也会立即切换。时间片轮转调度中的时间片大小很重要。从一个进程切换到另一个进程是需要一定时间的——保存和载入寄存器值及内存映像、更新各种表格和列表、清除和重新调入缓存等。**进程切换（process switch）** 有时候也称 **上下文切换（context switch）**。时间片太短容易导致过多的进程切换，降低CPU效率；而时间片太长可能导致短交互请求的响应时间变长。将时间片设为20~50ms通常是一个合理的折中选择。轮转调度一般用于交互式系统。

**优先级调度**：优先级调度的基本思想是：给每个进程指定一个优先级，优先级越高的进程越先运行。而轮转调度中的每个进程的优先级是一样的。

OSTEP 的读书笔记中有更多的调度算法，见 [进程调度](/notebook/reading_notes/ostep/virtualization-cpu/#进程调度)。


## 参考资料
1. ANDREW S. TANENBAUM, HERBERT BOS. *Modern Operating Systems, 4th Edition*. Pearson, 2015.
2. [Critical section](https://en.wikipedia.org/wiki/Critical_section).
