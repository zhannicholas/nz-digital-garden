---
date: "2020-12-13T18:43:36+08:00"
title: "HotSpot引擎架构"
authors: Nicholas Zhan
categories:
  - Java
tags:
  - JVM
draft: false
toc: true
---
> 这篇笔记主要来自于[The Java HotSpot Performance Engine Architecture](https://www.oracle.com/technetwork/java/whitepaper-135217.html)，感觉主要是在讲 JDK8中 HotSpot VM 的整体架构。

Java HotSpot VM 原来是 Sun 公司为 Java 平台实现的高性能虚拟机，是 Java SE 的基础组成部分。为了使 Java 应用达到达到最佳的性能，HotSpot 采用了很多高级技术，包括先进的内存模式、垃圾收集器和自适应优化器。

## HotSpot VM架构

### 内存模型（Memory Model）

#### 对象的访问定位

Java 程序通过栈上的引用（reference）操作堆上的具体对象。在早期 JVM 中，比如 Classic VM，对象的访问定位是通过 **间接句柄（indirect handle）** 实现的。由于引用中存放的是句柄的地址，所以在对象被移动时，只需要改变句柄中到对象实例数据的指针即可。这一点虽然可以简化垃圾回收过程中对象的重定位过程，但却成为了性能瓶颈，因为在 Java 中通过句柄访问实例变量需要进行 **两次** 间接访问。

在 HotSopt VM 中，对象的访问定位是通过 **直接指针（direct pointers）** 来实现的，只需要 **一次** 访问就可以获取到实例变量。当对象在内存回收过程中被移动时，垃圾收集器需要负责找到并更新所有到该对象的引用。

#### 两字（Two-Word）的对象头

HotSpot VM 中的对象头大小为两个机器字，而 Classic VM 中的对象头为三个字。通常，Java 对象都很小，所以对象头的大小对空间消耗的影响还是很大的。对象头的第一个字（mark word）包含了 hashCode 和 GC 的状态等信息，而第二个字（kclass pointer）是一个指向对象所属类（class）的指针。只有数组对象的对象头中有第三个部分——这一部分记录了数组的大小。

#### 以对象表示的反射数据

类、方法和其它内部反射数据都直接被表示成堆上的对象。这既简化了 VM 内部的对象模型，也允许类被为其它对象设计的垃圾回收器回收。

#### 支持原生线程

每个线程的方法活动栈都是使用宿主操作系统的栈和线程模型表示的。Java 方法和原生方法使用的是同样的栈，因此 C 和 Java 之间的调用更快。通过使用操作系统的线程调度机制，Java 线程是完全可抢占的。使用原生操作系统线程和调度机制的一个主要优点就是可以透明地利用原操作系统的多处理机制。

### 垃圾收集（Garbage Collection）

HotSpot VM 的内存系统是分代的，这为不同应用场景下选择不同垃圾收集器提供了极大的灵活性。为了满足不同的停顿时间和吞吐量要求，HotSpot 支持选择不同的垃圾回收算法。

#### 准确性

HotSpot 垃圾收集器是一个完全准确的垃圾收集器。相反，很多其它的垃圾收集器都是保守的（conservative）或部分准确的。保守式垃圾回收吸引人的一点在于，它可以很容易地被添加到不支持垃圾收集的系统中，但它容易出现内存泄漏，还可能导致堆上碎片。

保守式收集器并不确切的知道所有对象引用的位置。因此，它必须假设一个可能引用某个对象的内存字就真的是对象引用。这意味着它可能会犯一些错误，例如：当一个整数当作是一个对象指针。看起来像指针的内存单元被认为是真的指针，GC 就变得不准确了。这会带来一些负面影响：第一，可能发生无法复现或调试的内存泄漏。第二，因为保守式收集器可能犯错，因此它必须这么做：要么使用句柄来间接引用对象（这降低了性能），要么避免移动对象（因为移动对象需要更新所有在该对象上的引用，这在收集器不能确切知道一个表面上的引用是否是真的引用的情况下是无法做到的）。由于缺乏移动对象的能力，保守式收集器可能导致内存碎片，也无法使用一些高级的分代复制收集算法。

#### 分代复制收集（Generational Copying Collection）

分代垃圾收集器利用了一个事实：在大多数程序中，绝大多数（通常超过95%）对象的存活时间都非常短。通过将新生对象放置在一个单独的空间里，分代收集器可以实现：
1. 因为新生对象的空间是连续分配在一个单独的空间里的，分配速度是非常快的，因为这只需要更新一个指针并做一次该空间是否用尽的检查。
2. 在该空间用尽之前，其中的大多数对象都已经死亡了。这个时候收集器只需要简单地将少数存活的对象移动到其它地方，不再需要为该空间内的死亡对象做其它回收操作。

#### 并行年轻代收集器（Parallel Young Generation Collector）
上面描述的单线程复制收集器适用于很多场合，但它会成为并发程序中的瓶颈。为了充分利用多处理器上的多个 CPU，HotSpot VM 还为年轻代提供了一个可选的多线程收集器，其中使用了多个并行工作的线程来完成存活对象的追踪和复制。这减少了收集年轻代空间的暂停时间，并最大化了垃圾收集的吞吐量。

当移动对象时，并行收集器努力使相关对象在一起，从而提高内存的局部性以及缓存的利用率，并提高了分配器的性能。这是通过采用 **深度优先的顺序** 复制对象来实现的。

#### 标记-整理收集器（Mark-Compact Collector）

尽管分代复制回收器可以高效地收集大多数死亡对象，但长期存活的对象仍然在年老对象区域聚集。有时候，由于可用内存过低或者显式要求，年老对象上的垃圾收集必须进行。HotSpot VM 默认使用标准的标记-整理回收算法来进行年老对象区域的垃圾收集，算法从 **RC Roots** 开始遍历整个存活对象图，然后进行清理，整理死亡对象留下的空隙。通过压实堆中的空隙而不是将它们收集到空闲链表中，可以避免内存碎片。

#### 并发标记-清除收集器（Concurrent Mark-Sweep Collector）

对于那些使用大量堆空间的应用，默认的年老代标记-整理收集器可能引起程序中断，因为应用线程被暂停的时间和堆的大小成比例。在应用线程被暂停的非常短暂的时间内，HotSpot VM 为年老对象空间实现了一个可以利用处理器的空闲时钟周期（或空闲处理器）来收集大堆的并发收集器。当应用线程执行时，收集器会进行追踪和清理工作。有时，这会降低应用的最大吞吐量，因为一些处理器的时钟周期被用来进行并发收集。然而，在平均和最坏的情况下，垃圾收集的暂停次数通常降低了1~2个数量级，这使应用的响应时间变得更加的平滑，不会出现默认的同步标记-整理算法在大堆上可能发生的突发。

#### 并行年老代收集器（Parallel Old Generation Collector）
为了提高占用那些使用巨大堆空间应用的可扩展性，HotSpot VM 为年老代实现了一个并行的标记-整理收集器。CMS 收集器主要关注的是如何降低暂停时间，而并行年老代收集器关注的是如何在暂停整个应用（stop-the-world）的情况下同时使用多个线程以提高吞吐量。

### 超快的（Ultra-Fast）的线程同步
Java 提供了语言级别的线程同步，使得它能够非常容易地用细粒度锁来表达多线程程序。而 Classic VM 等早期 JVM 中，同步的实现和其它操作比起来非常低效，细粒度同步因此成了主要的性能瓶颈。

HotSpot VM 采用自适应自旋技术实现竞争性同步，采用超快的常量时间技术实现非竞争性同步，极大的提升了同步性能。

### 64 位架构

早期的 HotSpot VM 的寻址空间被限制为 4GB 内存，即使在 64 位操作系统中也是这样。而在 64 位的 JVM 中，Java 程序可以使用所有的内存。

## HotSpot 编译器

为了提升程序的性能，很多为传统语言开发的编译技术也被应用到了 Java 中。JIT（just-in-time）编译器将 Java 字节码迅速翻译成机器码。然而，JIT编译存在一些问题：
1. 由于编译器在用户时间内运行，它的编译速度非常重要：如果它不是非常快，用户会在启动程序时察觉到明显的延迟。因为高级优化通常会显著减慢编译速度，所以进行高级优化非常困难。
2. 即使 JIT 有时间进行所有的优化，Java 也还是没有 C 或 C++ 那样高效。原因有很多：
    * Java 是动态安全的，这意味着 Java 程序不会违反语言的语义，也不会直接访问任意内存。因此，Java 中的动态类型检查必须非常频繁的执行。
    * Java 在堆上分配所有对象，而 C++ 中的多数对象是在栈上分配的。这意味着对象的分配速度在 Java 中比在 C++ 中更高。此外，Java 支持自动垃圾收集，它和 C++ 的内存分配开销（包括潜在的清除写屏障的开销）截然不同。
    * Java 中的大多数方法调用都是虚的（virtual），并且比 C++ 更加频繁。这不仅意味着方法调用性能更显著，还意味着堆方法调用进行静态编译优化更加困难。
    * 由于支持类的动态加载，Java 程序可以迅速被改变。这使得一些全局优化难以进行。

为了解决Java语言的性能问题，HotSpot 采用了自适应优化技术。

### 热点检测（Hot Spot Detection）

几乎所有的程序都将绝大部分执行时间花在了执行少数代码上。基于这一点，自适应优化技术解决了 JIT 编译中的问题。与其逐方法进行即时编译，HotSpot VM 使用解释器立即运行程序，并分析执行的代码以检测热点代码片段。然后，专心使用全局原生代码编译器编译热点代码。通过避免编译不常执行的代码，HotSpot 编译器可以更加重视程序中的对性能至关重要的部分，而不必增加全部的编译时间。

### 方法内联（Method Inlining）

Java 中虚方法调用的频率是一个重要的优化瓶颈。HotSpot 的自适应优化器一旦收集到了热点代码的信息，它不仅会把热点代码编译成原生代码，还会在其上进行大量的方法内联。

内联可以降低方法调用的动态频率，这就节省了相关方法调用的时间。更重要的是，内联会为优化器提供更大的代码块，是传统编译器优化更加高效。

### 动态去优化（Dynamic Deoptimization）

内联基于某种形式全局分析，而动态加载是与之冲突的，因为动态加载会改变程序中的全局关系。因此，HotSpot VM 必须能够动态的反优化之前已优化的热点代码。

## 参考资料

1. [The Java HotSpot Performance Engine Architecture](https://www.oracle.com/technetwork/java/whitepaper-135217.html).
