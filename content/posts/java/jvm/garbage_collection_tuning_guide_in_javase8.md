---
date: "2020-12-13T18:40:26+08:00"
title: "垃圾回收调优指南(Java SE 8)"
authors: Nicholas Zhan
categories:
  - Java
tags:
  - JVM
draft: false
toc: true
---
> 这篇笔记地主要内容来自[Java Platform, Standard Edition HotSpot Virtual Machine Garbage Collection Tuning Guide](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/introduction.html)。文章中介绍了一些调优目标以及 JDK 8中 Hotspot VM 提供的一些垃圾收集器，并提出了很多调优建议。

**GC（Garbage Collector）** 是一个内存管理工具，它通过以下操作实现了自动内存管理：
1. 将新生对象分配到 **年轻代（Young Generation）**，并将足够老的对象提升到 **年老代（Old Generation）**。
2. 通过并发（或并行）标记阶段找出年老代中的存活对象。当整个 Java 堆的空间使用率超过阈值时，HotSpot VM 就会触发标记阶段。
3. 通过并行复制整理存活对象，以释放堆空间，恢复可用内存。

## Ergonomics

> *Ergonomics* is the process by which the Java Virtual Machine (JVM) and garbage collection tuning, such as behavior-based tuning, improve application performance.

JVM 会根据所运行平台选择默认的 GC、堆大小和运行时编译器等。此外，基于行为的调优会动态地调整堆大小以满足不同应用的要求。

### 基于行为的调优

Java SE 为 *并行收集器* 提供了两个参数以实现不同的应用行为：**最大暂停时间（maximum pause time goal）** 和 **吞吐量（application throughput goal）**。这两个参数在其它收集器中是不可用的。在某些时候，预期行为可能不会出现，因为应用需要一个至少能存放下所有存活对象的堆空间。对堆空间的最小要求可能会妨碍达成预期目标。

#### 最大暂停时间

暂停时间指的是 GC 停止应用并回收内存所花费的时间。GC 会维护一个平均暂停时间以及这个平均暂停时间上的方差，平均暂停时间是加权的，越晚发生的停顿权重越大。当平均暂停时间与方差之和大于最大暂停时间时，HotSpot就认为GC没有满足最大暂停时间的要求。

最大暂停时间目标是通过命令行参数 `-XX:MaxGCPauseMillis=<nnn>` 来指定，它告诉 GC 期望的暂停时间不应该超过 `<nnn>` 毫秒。为了达到这个目标，GC 会调整堆的大小以及其它相关参数，这些调整可能会让 GC 的执行更加频繁，从而有可能降低程序的吞吐量。GC 会优先满足最大暂停时间目标而不是吞吐量目标，但有时候可能连暂停时间目标也满足不了。

#### 吞吐量

吞吐量是用 GC 时间和非 GC 时间(应用时间)来衡量的，相关的命令行参数是 `-XX:GCTimeRatio=<nnn>`。GC 时间与应用时间的比值为 `1/(1 + <nnn>)`。例如，`-XX:GCTimeRatio=19` 表示 GC 时间占总时间的 5%。

GC 时间为年轻代与年老代 GC 时间的总和。如果吞吐量目标没有满足，GC 会增大分代的大小，从而使应用能在两次垃圾收集之间的执行更久。

#### 内存占用

当最大暂停时间和吞吐量都达到要求后，GC 会缩小整个堆空间直到某个目标（当前版本 JVM 中总是指吞吐量）不再满足，然后再尝试满足那个目标。

### 调优策略

* 除非你知道你所需要的堆空间比默认最大堆大小还要大，否则不要设置最大堆内存，而是为你的应用设置一个足够大的吞吐量目标。
* 为了使应用达到期望的吞吐量，堆的通常会自动扩容和缩容。应用行为的改变也可能导致堆容量的改变。
* 如果堆已经达到了最大值，而吞吐量仍然低于期望值，那么你的最大堆内存就设置得太小了。这个时候，将最大堆内存设置为一个稍小于总物理内存的值，再次运行应用，如果吞吐量还是低于期望值，那么你的吞吐量目标就定得太高了（已经超过物理内存所能提供的最大吞吐量了）。
* 如果吞吐量目标达到了，但应用的暂停时间太长了，就设置一个最大暂停时间目标。为了达到最大暂停时间目标，期望的吞吐量可能又无法达到了，这个时候，需要进行权衡，选择一个折中的目标。
* GC 为了达到设置的目标，通常会引起堆大小的振荡，即使应用已经处于一个稳定状态也一样。最大吞吐量目标与最大暂停时间目标和内存占用目标时相互竞争的，因为前者可能需要更大的堆，而后两者可能需要的是更小的堆。

## 分代

人们从经验中发现，绝大多数应用都具备一些共同的特点。为了使垃圾回收过程更加高效，分代收集利用了这些特点，其中最重要的一条就是 **弱分代假说（weak generational hypothesis）** ——大多数对象的存活时间都非常短。内存以代的形式进行管理，代实际上是一个存放有不同年龄对象的内存池。当某个代被填满时，该代上面的垃圾回收就会发生。

下图展示了 GC 中（不包括并行收集器和 G1）默认的堆布局:

![Default Arrangement of Generations, Except for Parallel Collector and G1](/images/java/jvm/default-arrangement-of-generations-except-for-parallel-collector-and-g1.png)

### 设置分代大小

有很多参数可以影响堆的大小。下图展示了堆中 *已提交空间（committed space）* 与 *虚拟空间（virtual space）* 的区别：

![Heap Parameters](/images/java/jvm/heap-parameters.png)

`-Xmx` 用来指定堆的保留空间，如果 `-Xms` 参数的值比它小，那么并不是所有的保留空间都会被立即提交给 JVM，其中未提交的部分就是上图中用Virtual 标出来的那一部分。堆的不同部分（年轻代和年老代）可以按需扩张，直到达到虚拟空间的上限。

#### 整个堆

下面所讨论的堆容量的扩张与收缩和默认堆大小并不适用于并行收集器，然而控制堆大小和分代大小的参数却是适用于并行收集器的。最影响垃圾回收性能的因素就是可用内存的总大小，因为垃圾收集在堆被填满时才发生，所以垃圾回收的吞吐量与可用内存总大小成反比。

默认情况下，JVM 会在每次进行垃圾回收时扩张或缩减堆的容量，以便将空闲空间与存活对象的比值限制在一个特定范围（百分比）内，这个范围是通过参数 `-XX:MinHeapFreeRatio=<minimun>` 和 `-XX:MaxHeapFreeRatio=<maximum>` 来设置的，而整个堆的大小边界是通过参数 `-Xms<min>` 和 `-Xmx<max>` 来确定的。如果某个分代中空闲空间的比例低于 `<minimum>`，该分代就会扩张，从而将空闲空间的比例保持在 `<minimum>`。类似地，如果空闲空间的比例高于 `<maximum>`，该分代就会被收缩，从而将空闲空间的比例保持在 `<maximum>`，不过这受限于分代的最小容量。

下面是一些服务端应用中有关堆大小的通用准则：
* 除非暂停时间成为了你的最大问题，就尝试分配尽可能多的内存给 JVM。默认值通常都太小了。
* 将 `-Xms` 和 `-Xmx` 设为相同值，从而避免 JVM 对堆进行扩容或缩容。但是，如果你的设置不当的话，JVM 是不会帮你救你的。
* 通常情况下，当你增加处理器时，你也应该增加可用内存，因为内存分配可以是并行的。

#### 年轻代

除可用内存大小之外，第二个最影响垃圾回收性能的就是年轻代占堆空间的比例了。通常，年轻代越大，minor GC 发生的频率就越低。然而，在有限的堆空间下，年轻代越大就意味着年老代越小。而通常情况下，年老代越小，major GC 就越频繁。因此，最优的设置取决于应用中对象存活时间的分布情况。

默认情况下，年轻代的大小由参数 `NewRatio` 控制。例如，`-XX:NewRatio=3` 表示年轻代与年老代的比例为 1:3，即年轻代占整个堆空间的 1/4。`NewSize` 和 `MaxNewSize` 参数用来指定年轻代容量的下限与上限，两者的值相同会使年轻代的大小保持不变。

##### 调整 Survivor 空间的大小

我们可以使用 `SurvivorRatio` 参数来调整 Survivor 空间的大小，但这通常不会给性能带来多大的影响。例如，`-XX:SurvivorRatio=6` 表示一个 Survivor 空间与 Eden 区大小之比为 1:6，即每个 Survivor 空间的大小为 Eden 区的 1/6，为年轻代的 1/8。

若 Survivor 空间过小，复制回收时溢出的对象就会直接被提升到年老代；若 Survivor 空间过大，就会造成空间的浪费。在每次垃圾回收中，JVM都会选择一个阈值（对象在被提升到年老代之前可以被复制的次数），这个阈值的目的是将 Survivor 空间的占用率保持在 50%。

对服务端应用而言，下面是一些通用准则：
* 先决定能够分配给 JVM 的最大堆内存，然后找出年轻代的最佳设置值。
    * 注意：最大堆内存应该总是小于机器已安装内存，这样可以避免过多的页错误和颠簸。
* 如果堆大小是固定的，那么增大年轻代就会缩小年老代。将年老代的大小保持在一个足够大的值，以便它在任何时候都能容纳下应用中的存活对象，并且还有一些松弛空间（10% 到 20% 甚至更多）。
* 在之前所陈述的永久代的约束条件下：
    * 为年轻代分配足够的内存。
    * 当你增加处理器时，你也应该增加年轻代的大小，因为内存分配可以是并行的。

## 可用收集器

Java HotSpot VM 包含三种不同类型的 GC，每种 GC 都有不同的性能特征：
* **串行收集器（serial collector）** 使用一个线程完成所有的回收工作，由于不存在线程间通信的开销，它还是相对高效的。串行收集器最适合用在单处理器机器上，因为它无法利用多处理器机器上的多个 CPU，尽管它对多处理器上运行的小型应用（内存最大约100MB）来说还是很有用的。串行收集器在某些硬件和操作系统配置下会默认启用，也可以通过 `-XX:+UseSerialGC` 选项显式使用它。
* **并行收集器（parallel collector）** 又称 **吞吐量收集器（throughput collector）**，它并行的进行 minor GC，这能显著降低 GC 的开销。它是为运行在多处理器硬件上的中大型应用准备的。并行收集器也是某些硬件和操作系统配置下的默认 GC，我们也可以通过 `-XX:+UseParallelGC` 选项显式使用它。
    * **并行整理（parallel compaction）** 使并行收集器能够并行进行 major GC。如果没有并行整理，major GC 就会使用单线程以串行地方式进行，这极大的限制了应用地可伸缩性。当 `-XX:+UseParallelGC` 选项被使用时，并行整理会被默认启用。若要关闭它，可以使用 `-XX:-UseParallelOldGC` 选项。
* **并发收集器（mostly concurrent collector）** 的大部分工作都是并发进行的，从而使应用被暂停的时间保持在一个较短的范围内。并发收集器为那些响应时间优于吞吐量的中大型应用设计的，因为用来减小暂停时间的技术同时会降低吞吐量。HotSpot VM 提供了两个最大并发收集器：
    * CMS：通过 `-XX:+UseConcMarkSweepGC` 启用。
    * G1：通过 `-XX:+UseG1GC` 启用。

### 如何选择 GC

除非你的应用对暂停时间有非常严苛的要求，否则先运行应用并让 JVM 自己选择一个 GC。按需调整堆的大小以提高性能，如果期望的性能无法满足，就使用下面的准则选择 GC：
* 如果应用很小（堆空间不超过 100MB），使用 `-XX:+UseSerialGC` 选择串行收集器。
* 如果应用运行在单处理器上且对暂停时间无要求，就让 JVM 自己选择 GC，或者选择串行收集器（`-XX:+UseSerialGC`）。
* 如果应用的峰值性能最为重要，且对暂停时间无要求或暂停 1 秒及以上时间是可接受的，就选择并行收集器（`-XX:+UseParallelGC` ）。
* 如果响应时间比总吞吐量更重要，且暂停时间必须保持在约 1 秒内，就选择并发收集器（`-XX:+UseConcMarkSweepGC` 或 `-XX:+UseG1GC`）。

如果采用了推荐的 GC，但应用还是达不到期望的性能，先尝试调整分代的大小。如果还是不行，就再尝试不同 GC：在多处理器上，用并发收集器减小暂停时间，用并行收集器提升吞吐量。

## 并行收集器

并行收集器和串行收集器类似，主要不同在于它采用了多个线程以加速回收垃圾。GC 线程的数量可以通过命令行参数 `-XX:ParallelGCThreads=<N>` 来指定。

### 分代

之前有提到，并行收集器中的堆布局和普通的串行收集器是不同的。下图展示了并行收集器中的分代布局：

![Arrangement of Generations in the Parallel Collector](/images/java/jvm/arrangemant-of-generations-in-the-parallel-collector.png)

### Parallel Collector Ergonomics

#### 目标优先级

当使用并行收集器时，HotSpot VM 默认会按照以下顺序实现调优目标：
1. 最大暂停时间目标。
2. 吞吐量目标。
3. 最小内存占用目标。

首先满足暂停时间目标，然后才会考虑吞吐量。当前面两个都满足时，才会考虑内存占用。

#### 调整分代大小

收集器会记录并在每次垃圾收集之后更新一些统计数据(如平均暂停时间)，这些统计数据会帮助GC判断是否已经达到调优目标或做出一些调整。需要注意的是：收集器并不会使用显式地进行垃圾回收（例如 `System.gc()`）时形成的数据。

分代容量的增长和缩减是以固定百分比进行的，并且增长率和缩减率不同。默认情况下，分代会以 20% 的增量扩容，而以 5% 的增量压缩。年轻代与年老代容量扩容的增量可以通过 `-XX:YoungGenerationSizeIncrement=<Y>` 与 `-XX:TenuredGenerationSizeIncrement=<T>` 来指定，而缩容的增量是通过 `-XX:AdaptiveSizeDecrementScaleFactor=<D>` 指定的。如果扩容的增量为X个百分比，则缩容的增量为 X/D 个百分比。

## 并发收集器

HotSpot VM 提供了两个 **并发收集器（mostly concurrent collector）**：
* Concurrent Mark Sweep (CMS) Collector：适用于那些偏爱更短的暂停时间并且可以接受同 GC 分享 CPU 的应用。
* Garbage-First (G1) Collector：为拥有大内存的多处理机设计的面向服务端应用的收集器。它尝试在实现高吞吐量的同时大概率满足应用对暂停时间的要求。

### CMS 收集器

通常情况下，那些有着相对较大的年老代并且运行在拥有 2 个或更多处理器的机器上的应用往往会从 CMS 收集器中获益。对于那些要求暂停时间非常短的应用来说，CMS 也是非常适合的。启用 CMS 收集器的命令行参数为 `-XX:+UseConcMarkSweepGC`。

和其它的 GC 类似，CMS 收集器也是基于分代的，因此 minor GC 和 major GC 都会发生。CMS 收集器试图通过使用独立的 GC 线程在应用线程执行期间并发地追踪可达对象来较少 major GC 引起的应用暂停时间。在每次 major GC 中，CMS 会在收集开始时（标记 GC Roots 直接可达的存活对象）短暂暂停所有应用线程，然后在收集过程中再次暂停（重新标记那些在并发标记中由于引用更新而漏标的对象）所有应用线程。第二次暂停通常比第一次暂停时间要长，在每次暂停期间，都会有多个线程同时进行垃圾收集相关工作。其余阶段（包括追踪存活对象和清除不可达对象）中，GC 线程都是在应用执行期间并发执行的。Minor GC 可以与正在进行的 major GC 重叠，工作方式也与并行收集器，但并行收集器在 minor GC 期间会暂停所有应用线程。

#### 并发模式失败

当 CMS 收集器无法在年老代空间耗尽之前完成回收不可达对象所占用的空间时，或者当 *赋值器（mutator）* 无法从年老代中为对象分配一个足够大的空闲块时，应用就会被暂停，GC会在所有应用暂停的情况下完成回收工作。**并发模式失败（Concurrent Mode Failure）** 指的就是 GC 无法 *并发地* 完成垃圾回收工作，这暗示我们该对 CMS 收集器进行调优了。

#### GC 时间过长与 OutOfMemoryError
CMS 收集器会在 GC 时间过长时抛出 OutOfMemoryError，即：当垃圾回收耗费的时间超过了总时间的 98%，并且回收的空间少于 2% 时，OutOfMemoryError 就会被抛出。这个特性是用来防止由于堆太小而导致应用运行时间太长，我们可以使用 `-XX:-UseGCOverheadLimit` 禁用它。

#### 浮动垃圾

由于应用线程会在 major GC 之间并发地执行，GC 追踪到的存活对象可能在垃圾收集结束之前变得不再可达，这类对象在当前进行的这一次回收过程中并不会被回收，它们被称为 **浮动垃圾（floating garbage）**。浮动垃圾的数量取决于并发收集的持续时间以及对象引用更新的频率，不过这些浮动垃圾会在下一次垃圾回收过程中被回收掉。

#### 并发回收何时开始

串行收集器会在年老代被填满之后暂停应用并进行 major GC。与此相反，并发收集的开始时间必须提前确定，以便收集工作在年老代空间耗尽之前完成。否则，应用会由于并发模式失败而被长时间暂停。有几种开始并发收集的方式：
* 基于历史数据，CMS 收集器会预估年老代还有多久被耗尽以及一次 major GC 会花多长时间。CMS 会以在年老代空间耗尽之前完成收集工作为目标开始进行垃圾回收，这些估算时间通常是保守的，因为并发模式失败的代价太高了。
* 当年老代中被占用的容量超过一个阈值时，垃圾收集工作也会开始。这个阈值默认约为 92%（可能在不同发行版本中做调整），我们可以通过 `XX:CMSInitiatingOccupancyFraction=<N>` 来指定这个阈值，其中 `<N>` 为一个范围在 (1, 100) 间的整数。

#### 增量模式

> 注意：增量模式在 Java SE 8 中正被弃用，将来的版本中可能会移除。

### G1 收集器

**Garbage-First（G1）** 收集器是一款面向服务端应用的收集器，目标为拥有大内存的多处理机。它尝试在实现高吞吐量的同时大概率满足应用对暂停时间的要求，这说明 G1 并不是一个实时 GC。

G1 将堆分成若干个大小相等的 *区域（region）*，每一个区域都是一个连续的虚拟地址空间。G1 通过并发标记阶段确定整个堆中对象的存活性，并发标记阶段完成后，G1 就知道哪些区域中的存活对象比较少了。它会先回收这些存活对象少的区域，而这通常可以为应用提供大量的空闲空间，这就是 G1（Garbage-First）名字的来源，即：G1 专注于收集和整理那些差不多被可回收对象（垃圾）占满的区域。

G1 会将堆中一个或多个区域中的存活对象复制到堆中的单个区域，复制过程中也会完成整理和释放空闲内存的工作。为了降低暂停时间并提升吞吐量，清空区域的操作在多处理机上是并行进行的。G1 采用的是“化整为零”的策略，在整理上比其它 GC 技高一筹：CMS 收集器不会整理堆，因而会导致内存碎片；并行收集器中的并行压缩过程是在整个堆上进行的，那会使暂停时间很可观。

值得注意的是：G1 并不是一款实时收集器，它大概率会满足暂停时间的要求，但并不是一定会满足。利用从已发生的垃圾回收中采集的数据，G1 会估计目标时间内能够回收区域的数量。G1 最关注的是如何为那些占用内存大且对 GC 延迟有要求的应用提供解决方案，这些应用的通常占用不低于 6GB 的堆空间，并且要求延迟时间低于 0.5 秒。

HotSpot 开发团队希望用 G1 来代替 CMS 收集器，它与 CMS 的主要不同点在于：G1 是一款整理式收集器。和 CMS 一样，G1 也是为那些要求低 GC 延迟的应用设计的。

下图展示了 G1 是如何划分堆的：

![Heap Division by G1](/images/java/jvm/heap-division-by-g1.png)

堆被划分为若干固定大小的区域（图中的灰色格子）。从逻辑上来讲，G1中依然有分代的概念。一组空闲区域被指定为逻辑年轻代（图中浅蓝色部分），分配操作就是从这个逻辑年轻代开始的。当年轻代满了之后，这组区域上的垃圾收集就会发生。有时候，这组区域以外的区域（年老区域，深蓝色）上的垃圾收集也会同时进行，这被称为 **混合收集（mixed collection）**。上图展示的正是混合收集，因为年轻区域和年老区域都正在被回收，被收集的区域在图中用红色格子标出。根据年龄，存活对象可能被复制到 Survivor 区域（标有"S"），也可能被复制到年老区域（图中未展示）。图中标有 "H" 的那些区域包含的是那些大小超过区域的一半或需要特殊对待的大对象。

#### 浮动垃圾

对象可能在G1回收的过程中死亡并未被回收。为了保证找到所有的存活对象，G1使用了一项叫做 **SATB（snapshot-at-the-beginning）** 的技术。SATB规定：任何在并发标记开始的时候存活的对象在整个 GC 过程中也是被认为是存活的。因此，G1 中也会出现浮动垃圾。

#### 卡表

如果 GC 不收集整个堆，GC 就必须知道哪里有从堆中未收集部分指向正被收集部分的指针。这在分代 GC 中很典型：未收集部分通常是年老代，正被收集部分是年轻代。**记忆集（remembered set）** 就是保存这些信息（年老代到年轻代的指针）的数据结构。**卡表（card table）** 是记忆集的一种具体实现，HotSpot VM 中用一个字节数组来表示卡表，每一个字节都被称为一张卡，每张卡都对应了堆中的一个地址空间。

## 参考资料

1. [Java Platform, Standard Edition HotSpot Virtual Machine Garbage Collection Tuning Guide](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/introduction.html).
