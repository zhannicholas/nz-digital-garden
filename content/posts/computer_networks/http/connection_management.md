---
date: "2020-12-13T17:05:53+08:00"
title: "HTTP：连接管理"
authors: Nicholas Zhan
categories:
  - HTTP
tags:
  - HTTP
draft: false
toc: true
---

HTTP连接是HTTP报文传输的关键通道。

## TCP连接
TCP/IP是全球计算机及网络设备都在使用的一个分层包交换协议集，几乎所有的HTTP通信都是由TCP/IP承载的。TCP连接时可靠的，它为HTTP提供了一条*可靠的比特传输管道*，从TCP连接一端传入的字节会在另一端以原有的顺序被正确地传送出来。

TCP会将数据切分为小的数据块发送，这些小的数据块就是**IP数据包（IP packets）**或**IP数据报（IP datagrams）**。这个时候，HTTP就位于*HTTP over TCP over IP*这个协议栈的最顶层，其安全版本HTTPS只是在HTTP和TCP之间插入了一个加密层（称为TLS或SSL）：

![HTTP and HTTPS network protocol stacks](/images/computer_networks/http/http-and-https-network-protocol-stacks.png)

HTTP在传送一条报文时，会以流的形式将报文内容通过一条打开的TCP连接按序传输。TCP在收到数据流之后，会先将数据流分割成小数据块（这些数据块被称为**段（segments）**），然后将段封装在IP数据包中，通过Internet进行传输。所有的这些工作都是由TCP/IP软件来处理的，每个TCP段都由IP数据报承载，从一个IP地址发送到另一个IP地址。每个IP数据包中都包括：
* 一个IP数据报首部（通常为20字节）。
* 一个TCP段首部（通常为20字节）。
* 一个TCP数据块（0或多个字节）。

TCP通过*端口号*来保持当前打开的TCP连接的正确运行。IP地址帮助我们找到正确的主机，而端口号帮助我们找到该主机上正确的应用程序。一条TCP连接由`<source-IP-address, source-port, destination-IP-address, destination-port>`四个值唯一标识。

## HTTP连接处理
HTTP允许客户端和最终的源端服务器中间存在一个**中间实体（intermediary）**（代理、缓存等）链。HTTP报文从客户端开始在中间设备间逐跳转发，最终到达源端服务器。或者从源端服务器出发，经过中间设备间的逐跳转发，最终达到客户端。

### Connection Header
HTTP的`Connection`首部是一个通用首部，它允许发送方或客户端声明一些只用于某个特定连接的选项，并且这些选项不会（也不能）被其它的连接使用。这些选项就是`Connection`首部字段中的一个由逗号分隔的*连接标签*列表。例如：可以用`Connection: close`来表面发送方希望在响应报文发送之后关闭连接。

`Connection`首部可以承载3中不同类型的标签：
* HTTP首部字段名：列出只与此连接有关的首部。
* 值`close`：说明当前的`request/response`操作完成之后就关闭这条连接。这是HTTP/1.0中的默认值。
* 任意标签值：描述此连接的非标准选项。

如果*连接标签*列表中包含了一些HTTP首部字段的名称，那么这些首部字段就包含了一些与连接有关的信息，这些信息是不能被转发出去的。在将HTTP报文被转发出去之前，代理必须删除`Connection`首部中列出的所有HTTP首部字段。`Connection`首部是一个逐跳首部，只适用于单各链路并且不应该被顺着链路向下传输。

### 串行事务处理与短连接
HTTP最早期的模型是**短连接（Short-lived connections）**。每一个HTTP请求都由它自己独立的连接完成，这意味着每发起一个HTTP请求之前都会进行一次TCP握手。这些连接的生命周期很短：每发起一个请求时都会创建一个新的连接，并在收到响应时立即关闭。

TCP协议握手本身就是很耗时的，所以TCP可以通过保持更多的热连接来适应负载。而短连接破坏了TCP具备的能力，因为新的冷连接降低了其性能。如果每个事务都需要（串行地建立）一条新的连接，那么TCP的连接时延和慢启动时延就会叠加起来。

短连接是HTTP/1.0的默认模型（如果没有指定`Connection`头，或它的值被设置为`close`）。而在HTTP/1.1中，只有当`Connection`被设为为`close`时才会用到短连接模型。

![Short-lived connections](/images/computer_networks/http/short-lived-connections.png)

短连接对TCP性能有先天的限制：每打开一个TCP连接都是相当耗费资源的操作。为了解决短连接模型的低效率问题，出现了几种新的模型：
* **并行连接（Parallel connections）**：通过多条TCP连接发起并发的HTTP请求。
* **持久连接（Persistent connections）**：重用TCP连接，以消除打开及关闭TCP连接时的时延。
* **管道化连接（Pipelined connections）**：通过共享的TCP连接发起并发的HTTP请求。
* **复用连接（Multiplexed connections）**：交替传送请求和响应报文。

### 并行连接
HTTP允许客户端打开多条连接，并行地执行多个HTTP事务，每个事务都有自己的TCP连接。

![Parallel connections](/images/computer_networks/http/parallel-connections.png)

例如，当一个网页里面包含多个组件的时候，如果并行连接能够克服单条连接的空载时间和宽带限制，网页的加载速度就会有所提高。时延可以重叠起来，如果单条连接没有充分利用带宽，空闲的带宽可以用来加载其它组件。

需要注意的是：并行连接可能会更快，但不一定总是更快。当一个较慢的客户端连接到较快的服务器上时，慢客户端的带宽可能很快被耗尽，接着就是带宽资源的竞争，这可能并不会带来性能的提升。因为，打开大量连接会消耗很多的内存资源，从而引发自身的性能问题。

很多浏览器都使用了并行连接，但它们一般都会将并行连接的总数限制在一个较小的值，而服务器可以随意关闭来自特定客户端的过量连接。

### 持久连接
Web客户端经常会打开到同一个站点的连接，并且可能会在将来的一段时间内对该站点发起更多的请求，这种性质就是**站点的局部性（site locality）**。

因此，HTTP/1.1（以及HTTP/1.0的各种增强版本）允许HTTP设备在事务处理结束之后保持TCP连接的打开状态，以便将来的HTTP请求可以重用现有的连接。在事务结束之后仍然保持在打开状态的TCP连接被称为**持久连接（persistent connections）**。非持久连接会在每个事务结束之后关闭，而持久连接会在不同事务之间保持打开状态，直到客户端或服务器决定将其关闭位置。

重用已经对目标服务器打开的空闲持久连接，客户端就可以避开建立连接阶段的高昂开销。此外，已经打开的连接可以避免慢启动的拥塞适应阶段，以便更快速地进行数据的传输。

持久连接有两种类型：
* 比较老的HTTP/1.0+中的`keep-alive`连接。
* HTTP/1.1中的`persistent`连接。

#### 并行连接 vs 持久连接
并行连接虽然可能比较快，但并行连接也有一些缺点：
* 每个事务都会打开/关闭一条新的连接，这会耗费时间和带宽。
* 由于TCP的慢启动特性，每条新连接的实际性能会有所降低。
* 可打开的并行连接的最大数量实际上是有限的。

持久连接有一些比并行连接更好的地方。持久连接可以有效的降低时延和建立连接的开销，还可以很方便地控制打开连接的数量。但是，一直打开的大量空闲连接会带来新的问题，它们会消耗客户端与服务器的资源。因此，管理持久连接时要特别仔细。

#### HTTP/1.0+中的Keep-Alive连接

![Persistent connections](/images/computer_networks/http/persistent-connections.png)

和短连接相比，持久连接节省了打开/关闭连接和TCP慢启动阶段的开销。

在当前的HTTP/1.1规范中，keep-alive已经被弃用了。但是，keep-alive握手操作仍然在浏览器与服务器之间广泛使用。

实现了HTTP/1.0 keep-alive连接的客户端可以通过在请求头里面包含`Connection: Keep-Alive`来告诉服务器它希望连接保持打开状态。若服务器也愿意为下一条请求而保持连接的打开状态，它也会将`Connection: Keep-Alive`放入响应头。如果响应报文中没有`Connection: Keep-Alive`，那么客户端就会认为服务器不支持keep-alive并且服务器会在发回响应报文之后关闭连接。

##### Keep-Alive选项
需要注意的是：`keep-alive`首部只是请求将连接保持在打开状态，而客户端和服务器不一定会同意进行keep-alive会话。它们可以在任何时候关闭空闲的keep-alive连接，也可以随意限制在keep-alive连接上处理的事务数量。

我们通过调整`Keep-Alive`通用首部中的一些由逗号分隔的参数来改变keep-alive行为：
* `timeout`参数是在Keep-Alive响应头中发送的。它代表着一个服务器可能会将连接保持在打开状态的时间的估计值。这不是一个承诺值。
* `max`参数也是在Keep-Alive响应头中发送的。它表示服务器还希望为多少个事务而将连接表示在打开状态，事务的数量也是一个估计值，不是承诺值。
* `Keep-Alive`首部还支持任意未经处理的属性，这些属性主要用于诊断和调试，语法为`name [=value]`。

`Keep-Alive`首部是可选的，只有在`Connection: Keep-Alive`出现时才会被使用。例如下面这两行表示服务器最多还会为另外5个事务保持连接的打开状态，或者将连接的打开状态再保持120秒：
```
Connection: Keep-Alive
Keep-Alive: max=5, timeout=120
```

##### Keep-Alive连接的限制与规则
使用keep-alive连接时有一些限制和需要特别说明的地方：
* 在HTTP/1.0中，keep-alive不是默认使用的。客户端必须发送一个`Connection: Keep-Alive`请求头来激活keep-alive连接。
* `Connection: Keep-Alive`首部必须随所有希望保持持久连接的报文一起发送。如果客户端没有发送它，服务器会在完成该请求之后关闭连接。
* 客户端可以根据响应报文中是否有`Connection: Keep-Alive`首部来判断服务器是否已经在发出响应报文之后关闭连接。
* 只有在无需检测连接关闭就能确定报文的实体主体的长度时，连接才能被保持在打开状态。
* 代理和网关必须执行`Connection`首部上的规则。代理和网关必须在转发或缓存报文之前移除`Connection`首部中出现的首部字段及`Connection`首部本身。
* 一般来说，不应该在代理服务器无法保证支持`Connection`首部的情况下建立keep-alive连接，这么做是为了避免**哑代理（dumb proxies）**问题的出现。
* 从技术上说，应该忽略所有来自HTTP/1.0设备的`Connection`首部字段，因为它们可能是由比较老的代理服务器误转发的。
* 除非重复的请求会产生副作用，客户端必须准备好在接收到响应之前连接就关闭时重发请求。

#### HTTP/1.0持久连接
HTTP/1.0逐渐停止了对keep-alive连接的支持，并用一种名为**持久连接（persistent connection）**的设计取代了它。

与HTTP/1.0+的keep-alive连接不同，HTTP/1.1的持久连接在默认情况下是激活的。也就是说，除非特别指明，否则HTTP/1.1会假定所有的连接都是持久的。若要在事务处理结束之后关闭连接，HTTP/1.1应用程序必须在报文中显式地添加一个`Connection: close`首部。但是，客户端和服务器是可以在任何时候关闭空闲连接的，所以不发送`Connection: close`并不意味着服务器会永远将连接保持在打开状态。

##### 持久连接的限制与规则
在使用持久连接时，有一些点需要注意：
* 在发送`Connection: close`请求头之后，客户端就不能在该连接上发送其它的请求了。
* 如果客户端不想在某条连接上发送另一个请求，那么它应该在当前的最后一个请求中发送`Connection: close`首部。
* 只有当连接上的所有报文都是正确的自定义的消息长度，连接才能被保持在打开状态。
* HTTP/1.1代理必须能够区分关系客户端和服务器的持久连接，每条持久连接都只适用于单跳传输。
* HTTP/1.1服务器不应该与HTTP/1.0客户端建立持久连接。
* 不管`Connection`首部内容如何，HTTP/1.1设备都可以在任意时刻关闭连接。
* 除非重复发起请求会产生副作用，否则如果客户端在收到整个响应之前连接就关闭了，客户端必须重新发起请求。
* 一个用户客户端对任何服务器或代理最多只能维持两条持久连接，以防止服务器过载。

### 管道化连接
HTTP/1.1允许在持久连接之上使用可选的**管道化连接（Pipelined connections）**：在响应到达之前，可以将多条请求放入队列，当第一条请求经过网络流向服务器时，其它的请求也可以开始发送了。在高延迟的网络条件下，管道化连接可以降低网络的环回时间，提高性能。

![Pipelined connections](/images/computer_networks/http/pipelined-connections.png)

在使用管道化连接时，有一些地方需要注意：
* 如果HTTP客户端无法确认连接是持久的，它就不应该使用管道。
* 服务器必须按照与请求相同的顺序回送HTTP响应。因为HTTP报文中没有序列号标签，所以响应不能失序。
* HTTP客户端必须做好连接可能在任意时刻关闭的准备，并重发所有未完成的管道化请求。
* HTTP客户端不应该使用管道化的方式发送会产生副作用的请求。

## 连接的关闭

### 异常关闭连接
所以的HTTP客户端、服务器或代理都可以在任意时刻关闭一条TCP传输连接，HTTP应用程序必须做好正确处理连接非正常关闭的情况。

每条HTTP响应都应该有精确的`Content-Length`首部，用来描述响应主体的大小。一些老的HTTP服务器会省略这个首部，这样就要通过服务器发出的连接关闭来确定数据的真实末尾。

### 正常关闭连接
TCP连接是双向的。TCP连接的每一端都有一个输入队列和一个输出队列，分别用于数据的读写。放在一端输出队列中的数据最终会出现在另一端的输入队列中。

![TCP connections are bidirectional](/images/computer_networks/http/tcp-connections-are-bidirectional.png)

#### 完全关闭与半关闭
应用程序可以关闭TCP输入与输出信道中的任意一个，或将两个都关闭。套接字调用`close()`会将TCP连接的输入与输出信道都关闭，这就是*完全关闭*。而套接字调用`shutdown()`只会单独关闭输入或输出信道，这就是*半关闭*。

关闭连接的输出信道总是安全的：另一端的对等实体会在读取完缓存区中的所有数据之后得到一个流结束的通知，从而知道信道已经关闭；除非应用程序知道另一端不会再发送其它数据了，关闭连接的输出信道是比较危险的：另一端的对等实体向已关闭的输入信道发送数据时，操作系统会回送一条"connection reset by peer"的消息。大部分操作系统都会将这种情况作为严重错误来处理，并删除对端还未读取的所有缓存数据。


## 参考资料
1. David Gourley, Brian Totty. *HTTP: The Definitive Guide*. O'Reilly Media, 2002.
2. [HTTP/1.x 的连接管理](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Connection_management_in_HTTP_1.x).
